Note on defining-categories
7/28/16, extended 7/24/19, 11/13/21
(in-package :sparser)

;;------ category names

Let's pick apart this definition, term by term.

(define-mixin-category action-verb
  :specializes subcategorization-pattern
  :instantiates nil
  :mixins (with-actor with-patient)
  :restrict ((actor (:or pronoun endurant))
             (patient physical))       
  :realization
    (:s actor
     :o patient
     :mumble (svo :s actor :o patient)))

If you trace-out (using ፡meta-period) the define-mixin-category macro,
you get to a call to the "expr" version of that call in the file
where all the action is: objects/model/categories/define.lisp.

The first thing you notice is this call.
     (find-or-make-category-object symbol :mixin)
Categories, like most other objects that have a name, are uniquely
identified by the symbol that names them. That call either returns
an already created category or instantiates a new one to go with
this symbol.

Categories are implemented as structs. They come in several varieties,
though the differences don't carry much weight at the moment.
The structure definitions are in objects/model/categories/structure.lisp.
The only functional difference today is between mixin and referential
categories. In a method definition its usually enough to refer to
them all as 'category'. (The definition of that simple, pre-model
category struct is in objects/chart/categories/object.lisp.)

As part of cataloging a new category, the newly instantiated struct
is bound to a symbol in the category package. And as these are lisp
symbols, their case doesn't matter.

sp> category::action-verb
#<mixin ACTION-VERB>
sp> category::Action-verB
#<mixin ACTION-VERB>
sp> (eq * **)
t

Note that successive calls to define-category using same name will all
use the same object. Just the values in its slots may be changed
according to the new values in the form. Most revisions to the local
slot values on a category take place immediately.


;;--------------------------------------------
;;------ decode-category-parameter-list

The next step is the process is decoding all the keyword arguments.
The function decode-category-parameter-list goes through them in
a deliberate order since there are some dependencies that have to be
respected.  This is the full signature on that function, showing us
what all the possible arguments are. It's unusual for a category
definition to specify all of them. In our example there are six,
which is probably the norm. It's worth reading though the code of
this function and looking at the pattern of the call to apply that
invokes it.

(defun decode-category-parameter-list (category
                                       &key mixins
                                       documentation
                                       instantiates
                                       specializes
                                       rule-label
                                       ((:binds var-v/r-pair))
                                       bindings
                                       ((:restrict restrictions))
                                       ((:realization rdata))
                                       lemma
                                       index )
  ... )

This is the standard 'description' ('d') displayed form of our
example. Note that 'ic' is a method. When we pass it a symbol
in the Sparser package (where you would be by default) it looks
up the corresponding category object.

sp> (ic 'action-verb)
#<mixin ACTION-VERB>
  [structure-object]

Slots with :instance allocation:
  plist             = (:mumble #<m-mdata: ACTION-VERB #<phrase svo>> :rules nil :restriction..
  symbol            = category::action-verb
  rule-set          = nil
  id-counter        = 0
  slots             = (#<variable actor> #<variable patient>)
  binds             = nil
  mix-ins           = (#<mixin WITH-ACTOR> #<mixin WITH-PATIENT>)
  realization       = (#<realization for action-verb>)
  lattice-position  = #<top-lp action-verb->subcategorization-pattern  245>
  operations        = #<operations for action-verb>
#<mixin ACTION-VERB>


;;--- Accessing fields

Given an instance of a structure you can access any of its fields
by using the field-specific access function generated by the
struct definition. With some exceptions, each of Sparser's struct
specify a prefix that you add to the name of the field to get
the access function. This is the :conc-name (for 'concatenate').

(defstruct (model-category
            (:include category)
            (:conc-name #:cat-)
            (:print-function print-model-category-structures))
  ... )

sp> (cat-slots category::action-verb)
(#<variable actor> #<variable patient>)

If no prefix is specified then you form the access function by using
the full name of the struct, e.g. edge-starts-at, word-morphology.

;;--- generics and the property list

There are a set of generic functions defined in the files of
objects/chart/generics/. They are convenient in that they do
the type-dispatches for you. In particular, the generic function
pname will return the print-name of most every sort of named
object in the system.

There is a property list field included on all of the chart-level
structures -- plist -- defined on the most basic component (:include)
of the system, 'unit'. The function plist-for returns the entire
property list.

sp> (plist-for category::action-verb)
(:mumble #<m-mdata: ACTION-VERB #<phrase svo>> :rules nil :restrictions
 ((actor (:or pronoun endurant)) (patient physical)) :super-categories
 (#<mixin ACTION-VERB> #<ref-category SUBCATEGORIZATION-PATTERN>
  #<ref-category LINGUISTIC> #<ref-category ABSTRACT> #<mixin WITH-ACTOR>
  #<mixin WITH-PATIENT> #<ref-category TOP>)
 :grammar-module #<grammar-module *MID-LEVEL-ONTOLOGY*> :file-location
 #P"SPARSER:MID-LEVEL;SUBCAT-PATTERNS.LISP")

The property lists is a list of tag-value pairs, where the tags are
keyword symbols. To get the value of a particular element in the
plist you use get-tag. You can setf that expression, and also remove
elements. See generics/plist.lisp)

sp> (get-tag :grammar-module category::action-verb)
#<grammar-module *MID-LEVEL-ONTOLOGY*>



;;----------------------------------

Now we walk through in individual statements in the definition of
action-verb to see how we get from that expression to this object.

;;--- :specializes subcategorization-pattern

This establishes the location of the category in the taxonomy of
all the other categories. The category being specialized has to
already have been loaded. We create a lattice object for it:
    #<top-lp action-verb->subcategorization-pattern  245>
that records this. The printer for top-lp conveniently
shows us that its immediate super-category is. This lattice object
should not be confused with the description-lattice that is used
to keep track of individuals and differentiate them by the values
on their variable bindings. 

;;--- :instantiates nil

This says that we can't make individuals of this category. This is
the case for any mixin, though the code doesn't yet enforce this.
In a normal, referential category this specifies where individuals of
this category should be indexed in the discourse history. It
defaults to the category, but we often want to generalize the
discourse records to a super category that is common to a lot
of more specific categories. Time is a good example.

;;--- :documentation "..."

Most of the things we model will never have analytic definitions.
The way we characterize them in English is going to be the real
arbiter of what users of the model should expect. Unless it's
really obvious, a documentation string is always a good idea.

;;--- :mixins (with-actor with-patient)

Mixins are so-called because Boston is ice-cream crazy, and the
Lisp mavens at MIT were no exceptio. They appreciated the
value of the metaphor when they were designing what ultimately
became the Common Lisp Object System -- CLOS. (The acronym is
pronounced like a word, not spelled out.)

The principal use of mixins at the moment is to provided
a category with additional variables beyond those that are
explicitly defined on the category using :binds. That is the
case here, where those two thematic role mixins are each
contributing a variable.

Like the category being specializes, the categories listed
in the :mixins field have to be defined earlier ('define before use').
They don't have to be mixin-categories, they can be any kind
of category. The idea is that the categories that you mix in to
the definition are contributing something that could be used
by other categories as well as this one. Today that's mostly
just variables, but with the options that k-methods present us
they could also be providing common behaviors. 

;;--- :restrict ((actor (:or pronoun endurant))
;;               (patient endurant))

Every variable that a category defines has to have a value
restriction before it can be used. The situation in the
subcat-patterns categories can be a bit extreme because the
variables provided by the thematic role categories they
mix in often don't have value restrictions on them, though
this is likely to change.

A :restrict expression has the same form as a :binds expression.
It is a list of lists. Each of these lists gives the name
of a variable, followed by the restriction to require of any
individual that we're going to bind to it.

So (actor (:or pronoun endurant)) says that in this category
(in action-verb), the 'actor' variable can be bound either
to an endurant or a pronoun. (I'm reworking things to make it
unnecessary to specify the pronoun.)

The normal purpose of these restrictions is to override the
value-restriction a variable was given in one of this category's
super categories. Usually to give the variable a narrower, more
domain-specific restriction.

You can only restrict variables that we provided by a super category
that this category inherits form, particularly mixin categories.
The restriction field is dealt with by handle-variable-restrictions
and it will signal an error if that constraint is not met.

Because variables have lexical scope, i.e each variable is uniquely
defined by the category on which it was defined (by :binds), the
effect of restricting a variable is to define a new variable, a new
instances of the lambda-variable struct. (See objects/model/
variables/structure.lisp.)

This variable has the same name as the variable it is restricting
but with the newly specified value restriction.

This can be confusing. The design goal is that variables are
always inherited. That way the variables are all shared. But the
taxonomy does not always faciliate this, so you should never assume
that two variables with the same name are the identical (EQ) object.

Every operation over variables gets them via the generic lookup function
find-variable-for-category. It knows how to properly walk up the
taxonomy so that it reaches the restricted version of a variable
before it would encounter the original.  The results are cached
so that we only have walk up the lattice once for each variable
before its lookup is a hash access.


;;--- Super category chains and mixins.

We continually make type-checks on the individuals we're dealing
with in order to dispatch to the proper operation. The function
'itypep' (individual typep) tests whether an individual inherits
from a particular super-category, e.g.
     (itypep vp 'control-verb)
from the assimilate-subject syntax function.

The definition of itypep and its suite of subroutines is overly
complex at the moment, but comes down to walking up the specialization
taxonomy and also the taxonomy above the category's mixin categories.
But that is only done once, and from then on we consult a cached
list -- we've converted pointer-chasing up a tree to a member
operation on a list. The function 'sc' is a convenient packaging
of the super-categories-of function.

sp> (sc 'action-verb)
(#<mixin ACTION-VERB> #<ref-category SUBCATEGORIZATION-PATTERN>
 #<ref-category LINGUISTIC> #<ref-category ABSTRACT> #<mixin WITH-ACTOR>
 #<mixin WITH-PATIENT> #<ref-category TOP>)

You might be able to see the layering here of moving up the
specialization links and they up from the mixins. The category
'top' is explicitly moved to the end of the list when creating
the cached list.

This cache is stored on the category's property list, where we store
a miscellany of things that aren't worth creating fields for, such as
any rules created by the category's realization specification.


;;---- :binds (variables)

The binds field, renamed var-v/r-pair in the constructor function is
dealt with by a call to define-variables to define the variables and
decode their value restriction. The standard expression-based constructor
is used to make the variable (define-lambda-variable), all that the
category-level call does is sort out how to separate out the restriction.

The legal pattern for a binding is a list that is either a dotted pair:
   (<var name> . <restricting category>)
or a two element list
   (<var name> <restricting category>)
or a larger list where the cdr of the list specifies the value restriction.

The restriction expression is handled by resolve-variable-restriction which is the final arbiter of what is a syntactically valid restriction, though
all it checks is the form of the restriction

symbol  -- taken to be a category. Resolve-or-make/symbol-to-category
   makes a simple category if it's not already defined.

list -- Must start with either the keyword :primitive or the keyword :or

For :primitive, the remainer of the restriction expression is just passed
through. For :or, the symbols in the remainder of the expression are
converted to categories, but the disjunctive type restriction created by
the :or can also include the specification any number of primitive
restrictions interspersed with the category restrictions.


;;------------------ Other fields

;;--- :index  :permanent vs. :temporary
Lets switch to these examples from our model of names and our model of time to understand the 'index' parameter. Decades ago with less available memory, marking the individuals of a category as :temporary or :permanent was significant. Individuals of temporary categories were reclaimed between runs. Now we can run for a long time before memory will clog with objects that can't be garbage collected, and there are other data structures we would flush before we have to apply this to individuals.

The index field is managed by the code in objects/model/categories/index-instances.lisp, particularly the function decode-index-field, which is always evaluated when the expression for the category is. This operation sets whatever the contents of the index field calls for.

;;--- style of linking
Many categories specify the kinds of indexing to use for its individuals: hashing on a particular variable or pair of variables, etc. See objects/model/individuals/index.lisp for all the options. In some cases, the linkages are so ideosyncratic that we have a provision for :special-case index, find, and reclaim operations, as with the name-word category.


(define-category  name-word
  :instantiates name
  :specializes  name
  :binds ((name :primitive word)
          (name-of collection)) ;; the named-objects it names
  :index (:permanent :apply
          :special-case
          ;; needed because these are extensively cross-linked to the
          ;; words involved, and those links have to be taken off by hand
          :find find/name-word
          :index index/name-word
          :reclaim reclaim/name-word))

;; :index (... :apply ...)
In practice, all individuals are entwined at some particular place in the description-lattice by warrant of their bindings -- variable/value combinations -- and can't be reclaimed. We do, however zero the bound-in fields of individuals, effectively reclaiming half of the binding information. The :apply keyword overrides this releasing to GC. It calls register-category-for-original-index which puts the name of the category on a list that is consulted in make-simple-individual where it signals to use the regular indexing which is done by calling index/individual. (We also call it if the description lattice isn't active.) The two-way linking provided by bindings makes it possible to identify subsequent references to names and things with names such as people.

;; :index (... :get ...)
We only occasionally need make a call to find-individual, and when we do what we get depends on correctly ordering the bindings that we specify or requires walking down through the indexes of the description lattice to find the instance of the individual that we're looking for (see m::unwind-to-i-with-lp for an example). For multi-binding categories like the months, it is simpler to just setup a direct link to the correct object via a hashtable, which we can do by including the keyword :get in the category's index field.

(define-category  month
  :specializes time
  :instantiates self
  :mixins (cyclic)
  :index (:permanent :key name :get)
  :binds ((name :primitive word)
          (abbreviation :primitive word)
          (position-in-year . ordinal)
          (number-of-days . number))
  :realization (:proper-noun name ))

The immediate effect of detecting this keyword (during decode-index-field-aux) is to pass the category to register-category-for-indexing with puts in on a table. The hash table is populated as part of make-simple-individual. It supports a generic function, get-by-name, and lets us set up calls like this.

(defun get-season (name)
  (if *description-lattice*
    (get-by-name category::season name)
    (find-individual 'season :name name)))

